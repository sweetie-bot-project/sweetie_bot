# FLEXBE SUBSTATE
#  
# DECISION OPERATOR
#
# (<op> ^name @name@ ^substate flexbe ^behavior @behavior-name@ ^param <p> [^interruptable [hard|soft]] ^process <proc>)
#   (<p> ^@parameter-name@ @parameter-value@)
#
# DESCRIPTION
#
# It waits or aborts for current FlexBe behavior if it presents. Then start behavior 
# with name @behavior-name@ and given parameters. 
#
# RESULT STATUSES:
#	* FlexBe behavior outcomes (standart convention): 
#		* succeed --- FlexBe behavior finished successfully
#		* failed --- internal error (execution system failure, invalid argument)
#		* invalid_pose --- invalid starting pose, unfinished movements.
#		* aborted --- behavior is aborted by request.
#		* other outcomes depending on FlexBe behavior.
#	* started --- behavior is started in asyncronous mode.
#
# SIDE EFFECTS
#
#	* event(^name error ^type internal ^subsystem flexbe) --- added on "failed" result
#	* event(^name error ^type invalid_pose ^subsystem flexbe) --- added on "invalid_pose" result
#
# IMPLEMENTATION
# 
# This state uses output link command instead of process belief

# ELABORATIONS

# if flexbe command is active laborate process
sp {flexbe*elborate*process
	(state <s> ^top-state 1 ^beliefs <b> ^io.output-link.flexbe.process <proc>)
-->
	(<b> ^process <proc>)
}

# START BEHAVIOR

# start flexbe behavior if no flexbe is running
sp {flexbe*propose*start*behavior
	(state <s> ^substate flexbe  ^io.output-link <ol> ^superstate.operator <sop>)
	(<ol> -^flexbe)
	(<sop> ^behavior <bh> ^param <p> ^proccess <proc>)
-->
	(<s> ^operator <op> +)
	(<op> ^name flexbe-start-behavior ^behavior <bh> ^param <p> ^process <proc>)
}

sp {flexbe*apply*start*behavior
	(state <s> ^substate flexbe ^operator <op> ^io.output-link <ol>)
	(<op> ^name flexbe-start-behavior ^behavior <bh> ^param <p> ^process <proc>)
-->
	(<ol> ^flexbe <cmd>)
	(<cmd> ^name <bh> ^param <p>)
	(<cmd> ^process <proc>)
	(write |Execute FlexBe behavior | <bh> (crlf))
}

# elaborate interruptability of flexbe command
sp {flexbe*elaborate*interruptability
	(state <s> ^substate flexbe ^process <proc> ^superstate.operator.interruptable <mode> ^io.output-link.flexbe <cmd>)
	(<cmd> ^process <proc>)
-->
	(<cmd> ^interruptable <mode>)
}

# WAIT BEHAVIOR
	
# wait flexbe behavior 
sp {flexbe*propose*wait 
	(state <s> ^substate flexbe)
-->
	(<s> ^operator <op> +, <)
	(<op> ^name flexbe-wait-cmd ^substate wait)
}

# COMPLETE BEHAVIOR

# cognition completion operator: even if substate is retracted results of flexbe execution must be gathered
sp {flexbe*propose*complete
	(state <s> ^bottom-state 1 ^io.output-link.flexbe <cmd>)
	(<cmd> ^status <status> ^process <proc>)
-->
	(<s> ^operator <op> +)
	(<op> ^name flexbe-complete-cmd ^substate flexbe ^type automatic cognition ^status <status> ^terminate-process <proc> ^cmd <cmd>)
}

sp {flexbe*apply*complete*remove-command
	(state <s> ^operator <op>^io.output-link <ol>)
	(<op> ^name flexbe-complete-cmd ^substate flexbe ^type cognition ^status <status> ^cmd <cmd>)
	(<ol> ^flexbe <cmd>)
-->
	(<ol> ^flexbe <cmd> -)
	(write |Flexbe: complete behavior with status | <status> (crlf))
}

# BEHAVIOR CONFLICT

# flexbe cmd in output link is present but not related to active process
# check if behavior is interruptable and abort it if it is possible
sp {flexbe*propose*abort
	(state <s> ^substate flexbe -^process ^io.output-link.flexbe <cmd>)
	(<cmd> ^interruptable {<< hard soft >> <abort-type>} -^abort)
-->
	(<s> ^operator <op> +)
	(<op> ^name abort-behavior ^cmd <cmd> ^abort <abort-type>)
}

sp {flexbe*apply*abort
	(state <s> ^substate flexbe ^operator <op>)
	(<op> ^name abort-behavior ^cmd <cmd> ^abort <abort-type>)
-->
	(<cmd> ^abort <abort-type>)
}
